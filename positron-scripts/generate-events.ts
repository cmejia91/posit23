/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Posit, PBC.
 *--------------------------------------------------------------------------------------------*/

import yaml from 'js-yaml';
import { readFileSync, writeFileSync } from 'fs';

const year = new Date().getFullYear();

interface PositronEventDefinitionParam {
	name: string;
	type: string;
	comment: string;
}

interface PositronEventDefinition {
	name: string;
	comment: string;
	params: PositronEventDefinitionParam[];
}

const eventsYamlFile = `${__dirname}/positron-events.yaml`;
const eventsYamlContents = readFileSync(eventsYamlFile, { encoding: 'utf-8' });
const events = yaml.load(eventsYamlContents) as PositronEventDefinition[];

type TypeMap = {
	[key: string]: string;
};

const rustTypesMap = <TypeMap>{
	boolean: 'bool',
	string: 'String',
	integer: 'i32',
};

const tsTypesMap = <TypeMap>{
	boolean: 'boolean',
	string: 'string',
	integer: 'integer'
};

function camel(value: string): string {

	let snakeCased = value.replace(/[A-Z]/g, (letter) => {
		return `_${letter.toLowerCase()}`;
	});

	if (snakeCased.startsWith('_')) {
		snakeCased = snakeCased.substring(1);
	}

	return snakeCased.replace(/_event$/, '');

}

function indent(value: string, indent: string): string {
	return value.replace(/(^|\n)/g, `$1${indent}`);
}

function generateRustEvent(event: PositronEventDefinition) {

	const lines: string[] = [];

	const comment = event.comment.trimEnd().replace(/(^|\n)/g, '$1/// ');
	lines.push(comment);
	lines.push(`#[positron::event("${camel(event.name)}")]`);
	lines.push(`pub struct ${event.name} {`);
	lines.push('');

	for (const param of event.params) {
		lines.push(`    /// ${param.comment}`);
		lines.push(`    pub ${param.name}: ${rustTypesMap[param.type]},`);
		lines.push('');
	}

	lines.push('}');
	lines.push('');

	return lines.join('\n');

}

function generateRustPositronEventEnum() {

	const lines: string[] = [];

	lines.push('#[derive(Debug, Clone)]');
	lines.push('pub enum PositronEvent {');
	for (const event of events) {
		const fullName = event.name;
		const shortName = fullName.replace(/Event$/, '');
		lines.push(`    ${shortName}(${fullName}),`);
	}
	lines.push('}');

	return lines.join('\n');

}

function generateRustClientEventHelper() {

	const dispatchLines = events.map((event) => {

		const params = event.params.map((params) => {
			return params.name;
		}).join(', ');

		const name = event.name.replace(/Event$/, '');
		return `PositronEvent::${name}(${params}) => Self::as_evt(${params}),`;

	}).join('\n');

	return `impl From<PositronEvent> for ClientEvent {
    fn from(event: PositronEvent) -> Self {
        match event {
${indent(dispatchLines, '            ')}
        }
    }
}`;

}

function updateRustEventsFile() {

	// Generate event definitions for Ark
	const rustEventsFile = `${__dirname}/../extensions/positron-r/amalthea/crates/amalthea/src/events/mod.rs`;
	const rustEvents = events.map(generateRustEvent);

	const rustHeader = `//
// mod.rs
//
// Copyright (C) ${year} by Posit, PBC
//
//
// Auto-generated by 'positron-scripts/generate-events.ts'.
// Please do not modify this file directly.
//

use crate::positron;

pub trait PositronEventType {
    fn event_type(&self) -> String;
}
`;

	rustEvents.unshift(rustHeader);

	const eventsEnum = generateRustPositronEventEnum();
	rustEvents.push(eventsEnum);
	rustEvents.push('');

	writeFileSync(rustEventsFile, rustEvents.join('\n'));

}

function updateRustClientEventsFile() {

	const path = `${__dirname}/../extensions/positron-r/amalthea/crates/amalthea/src/wire/client_event.rs`;
	const contents = readFileSync(path, { encoding: 'utf-8' });
	const lines = contents.split(/\r?\n/);

	const startIndex = lines.findIndex((line) => {
		return line.endsWith('/** begin rust-client-event */');
	});

	const endIndex = lines.findIndex((line) => {
		return line.endsWith('/** end rust-client-event */');
	});

	const replacement = generateRustClientEventHelper();
	lines.splice(startIndex + 1, endIndex - startIndex - 1, replacement);

	const replacedContents = lines.join('\n');
	writeFileSync(path, replacedContents);


}

function generateLanguageRuntimeEventType() {

	const lines: string[] = [];
	lines.push('export enum LanguageRuntimeEventType {');
	for (const event of events) {
		const lhs = event.name.replace(/Event$/, '');
		const rhs = camel(lhs);
		lines.push(`\t${lhs} = '${rhs}',`);
	}
	lines.push('}');

	return lines.join('\n');

}

function updatePositronDefinitionsFile(path: string, needsIndent: boolean) {

	const contents = readFileSync(path, { encoding: 'utf-8' });
	const lines = contents.split(/\r?\n/);

	const startIndex = lines.findIndex((line) => {
		return line.endsWith('/** begin positron-language-runtime-event-type */');
	});

	const endIndex = lines.findIndex((line) => {
		return line.endsWith('/** end positron-language-runtime-event-type */');
	});

	let replacement = generateLanguageRuntimeEventType();
	if (needsIndent) {
		replacement = indent(replacement, '\t');
	}

	lines.splice(startIndex + 1, endIndex - startIndex - 1, replacement);

	const replacedContents = lines.join('\n');
	writeFileSync(path, replacedContents);

}

function generateLanguageRuntimeEventDefinitions() {

	const lines: string[] = [];

	for (const event of events) {

		const comment = event.comment.trimEnd().replace(/(^|\n)/g, '$1// ');
		lines.push(comment);
		lines.push(`export interface ${event.name} extends LanguageRuntimeEventData {`);
		lines.push('');
		for (const param of event.params) {
			lines.push(`\t/** ${param.comment} */`);
			lines.push(`\t${param.name}: ${tsTypesMap[param.type]};`);
			lines.push('');
		}
		lines.push('}');
	}

	return lines.join('\n');

}

function updateLanguageRuntimeServiceEventDefinitions(path: string) {

	const contents = readFileSync(path, { encoding: 'utf-8' });
	const lines = contents.split(/\r?\n/);

	const startIndex = lines.findIndex((line) => {
		return line.endsWith('/** begin positron-language-runtime-service-events */');
	});

	const endIndex = lines.findIndex((line) => {
		return line.endsWith('/** end positron-language-runtime-service-events */');
	});

	const replacement = generateLanguageRuntimeEventDefinitions();
	lines.splice(startIndex + 1, endIndex - startIndex - 1, replacement);

	const replacedContents = lines.join('\n');
	writeFileSync(path, replacedContents);

}

updateRustEventsFile();
updateRustClientEventsFile();

const positronDefinitionsPath = `${__dirname}/../src/positron-dts/positron.d.ts`;
updatePositronDefinitionsFile(positronDefinitionsPath, true);

const extHostTypesPath = `${__dirname}/../src/vs/workbench/api/common/positron/extHostTypes.positron.ts`;
updatePositronDefinitionsFile(extHostTypesPath, false);

const lrsPath = `${__dirname}/../src/vs/workbench/services/languageRuntime/common/languageRuntimeService.ts`;
updatePositronDefinitionsFile(lrsPath, false);
updateLanguageRuntimeServiceEventDefinitions(lrsPath);
